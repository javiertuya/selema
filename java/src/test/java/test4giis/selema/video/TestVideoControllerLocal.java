package test4giis.selema.video;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThrows;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import giis.portable.util.FileUtil;
import giis.portable.util.Parameters;
import giis.selema.portable.selenium.CommandLine;
import giis.selema.portable.selenium.VideoControllerException;
import giis.selema.services.IVideoController;
import giis.selema.services.impl.ContainerUtil;
import giis.selema.services.impl.VideoControllerLocal;
import test4giis.selema.portable.Asserts;

/**
 * Partially integrated test of a Video Controller (local).
 * 
 * Tests are integrated with docker and do not need any external sever, 
 * but mock the video recorder using a lightweight
 * container. To be run in an independent workflow to run in CI.
 * 
 * This test does not requires a previous external setup (container is created in the code):
 * - Files to create the mock container are in video-controller/vcmock
 * - Folder were the mock video is created is video-controller/target/vcmock-mapped
 * - Folder were the mock video is copied is video-controller/target/vcmock-target
 */
public class TestVideoControllerLocal {
	static final Logger log = LoggerFactory.getLogger(TestVideoControllerLocal.class);

	protected static final String MOCK_CONTAINER = "selenium-video-mock";
	protected static final String MOCK_IMAGE = "selenium-video-mock-image";
	
	protected static final String ROOT = Parameters.getProjectRoot(); // for .NET compatibility
	protected static final String REPORTS = FileUtil.getPath(ROOT, Parameters.getReportSubdir());
	// note that the build context is platform independent, located in the java project
	protected static final String DOCKER_BUILD_CONTEXT = FileUtil.getPath(ROOT, "..", "video-controller/vcmock");

	// definitions of where the videos are stored, different setup for this and the subclasses
	protected String mappedFolder;
	protected String recordedVideo;
	protected String targetFolder;

	@Rule
	public TestName testName = new TestName();

	@BeforeClass
	public static void setUpAll() {
		log.debug("****** Building the mock video recorder docker image ******");
		String buildCommand = "docker build -t " + MOCK_IMAGE + " " + DOCKER_BUILD_CONTEXT;
		System.out.println(buildCommand);
		run(buildCommand);
	}

	@Before
	public void setUp() {
		log.info("****** Running test: {} ******", testName.getMethodName());
		fileSystemSetup();
		// Ensures a clean environment for both container and video files and folders
		run("docker stop " + MOCK_CONTAINER);
		run("docker rm " + MOCK_CONTAINER);
		FileUtil.createDirectory(FileUtil.getPath(REPORTS, "selema")); // just to do avoid report failures in GHA
		FileUtil.createDirectory(mappedFolder);
		FileUtil.createDirectory(targetFolder);
		FileUtil.deleteFilesInDirectory(mappedFolder);
		FileUtil.deleteFilesInDirectory(targetFolder);
		log.info("Test setup done");
	}
	
	protected void fileSystemSetup() {
		mappedFolder = FileUtil.getPath(ROOT, "..", "video-controller/target/vcmock-mapped");
		recordedVideo = mappedFolder + "/mock.mp4";
		targetFolder = FileUtil.getPath(ROOT, "..", "video-controller/target/vcmock-target");
	}

	protected IVideoController getController() {
		return new VideoControllerLocal(MOCK_CONTAINER, recordedVideo, targetFolder);
	}

	protected static void run(String command) {
		String output = CommandLine.runCommand(command);
		System.out.println(output.trim());
	}

	// This mocks what the external script will do to preload the containers, with some additional verification
	protected void preloadRecorder(boolean stopAfterRun) {
		String mappedVolume = FileUtil.getFullPath(mappedFolder);
		mappedVolume = mappedVolume.replace("\\", "/").replace("C:/", "//c/"); // fix for windows

		String runCommand = "docker run -d --name " + MOCK_CONTAINER + " -v " + mappedVolume + ":/app/videos "
				+ MOCK_IMAGE;
		System.out.println(runCommand);
		run(runCommand);
		ContainerUtil.waitDocker(MOCK_CONTAINER, "Display", "is open", 5);

		Asserts.assertIsTrue(CommandLine.fileExists(recordedVideo),
				"Video file generated by the mock container after preload does not exist");
		if (stopAfterRun) {
			ContainerUtil.runDocker("stop", MOCK_CONTAINER);
			ContainerUtil.waitDocker(MOCK_CONTAINER, "Shutdown complete", "", 5);
		}
	}

	@Test
	public void testPassRegularLifeCycle() {
		// Preload creates a video, but in the regular lifecycle, the recorded video should have been deleted after copy
		preloadRecorder(true);
		CommandLine.fileDelete(recordedVideo, true);
		Asserts.assertIsTrue(!CommandLine.fileExists(recordedVideo),
				"Video file generated by the mock should have been deleted by this test");

		doTestLifeCycle();
	}

	@Test
	public void testPassWhenPreviousRunDidNotDeleteVideo() {
		// This is the situation just after preload
		preloadRecorder(true);
		doTestLifeCycle();
	}

	@Test
	public void testPassWhenPreviousRunDidNotStopRecorder() {
		// To simulate that the previous run did not stop the container, do preload without stopping container
		preloadRecorder(false);
		
		// When we start a container that is started, there is no action, therefore no new video is created.
		// To simulate this situation, we delete now the video:
		// If the controller does not restart the container in this situation, no new video will be created
		// at the start will fail because video is not present during lifecycle
		CommandLine.fileDelete(recordedVideo, true);
		Asserts.assertIsTrue(!CommandLine.fileExists(recordedVideo),
				"Video file generated by the mock should have been deleted by this test");

		doTestLifeCycle();
	}

	protected void doTestLifeCycle() {
		IVideoController vc = getController();
		vc.start();
		Asserts.assertIsTrue(CommandLine.fileExists(recordedVideo),
				"Video file should be present during the lifecycle");
		vc.stop("copied-video.mp4");

		// The video should have been copied to target and removed from the mapped volume, and the container stopped
		Asserts.assertIsTrue(!CommandLine.fileExists(recordedVideo),
				"Video file generated by the mock container should have been removed");
		Asserts.assertIsTrue(CommandLine.fileExists(targetFolder + "/copied-video.mp4"),
				"Video file to be copied to the target folder does not exist");
		assertEquals("exited", ContainerUtil.getContainerStatus(MOCK_CONTAINER));
	}

	@Test
	public void testFailOnStartBecauseRecorderDoesNotExist() {
		// Do not preload, so that the containers are missing
		RuntimeException e = assertThrows(VideoControllerException.class, () -> {
			IVideoController vc = getController();
			vc.start();
		});
		Asserts.assertContains("No such container", e.getMessage());
	}

	@Test
	public void testFailOnStopBecauseCanNotCopyVideo() {
		// This is a common situation when the controller can't access to the recorded video
		// (usually because of file permissions). Simulated by deleting the video before stop
		preloadRecorder(true);
		IVideoController vc = getController();
		vc.start();
		CommandLine.fileDelete(recordedVideo, true);
		RuntimeException e = assertThrows(VideoControllerException.class, () -> {
			vc.stop("not-copied-video.mp4");
		});
		Asserts.assertContains("Video file not found after recording", e.getMessage());
	}

	@Test
	public void testFailOnStopBecauseCanNotStopRecorder() {
		// Not likely, but the recorder could fail in the middle of the process and be unable to be stopped
		// Simulated by removing the container before stop
		preloadRecorder(true);
		IVideoController vc = getController();
		vc.start();
		run("docker stop " + MOCK_CONTAINER);
		run("docker rm " + MOCK_CONTAINER);
		RuntimeException e = assertThrows(VideoControllerException.class, () -> {
			vc.stop("not-copied-video2.mp4");
		});
		Asserts.assertContains("No such container", e.getMessage());
	}

	@Test
	public void testContainerNotReadyAfterWaitForLogMessage() {
		// To complement the above, check that the waiting for the container log is able to fail after timeout
		run("docker run -d --name " + MOCK_CONTAINER + " " + MOCK_IMAGE);
		RuntimeException e = assertThrows(VideoControllerException.class, () -> {
			ContainerUtil.waitDocker(MOCK_CONTAINER, "Other docker log message", "that is not present", 1);
		});
		Asserts.assertContains("Container did not become ready in time", e.getMessage());
	}

}